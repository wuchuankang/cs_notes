## 面向对象

### 访问范围

1. private : 
    - 私有成员变量：    私有或者公有成员函数可以访问， 外部不可以
    - 私有成员函数：    公有成员函数可以访问，外部不可以

2. public ：
    - 公有成员变量、函数：  公有成员函数、外部可以访问

3. protect ：




### 内联成员函数

### 成员函数的重载和缺省参数

### 构造函数

- 用于初始化成员变量的，当没有自定义的构造函数，则**编译器** 会自动生成一个构造函数，但这个构造函数什么也不做；  
- 可以有多个构造函数，也就是说构造函数可以重载；
- 没有返回值;  
- **构造函数是用来初始化的，就是对成语变量分配内存空间和赋值这两个动作的，所以类中成员变量的写法只是个声明**
```cpp
struct Test
{
    Test(int a):i(a){}
    int i ;
};

struct Te
{
    Test test ;   // 其他类的成员变量，这里只是声明，不是定义，所以无需调用构造函数(Test 构造函数带有参数)，所以也就不需要给test填写参数，它的定义在Te的构造函数
    Te(Test &t)  // 构造函数，
    {
        test = t ;  //这里进行赋值操作，test对象先用调用 Test构造函数进行定义，再赋值，但是这里构造函数是有参的，所以编译器会报错 
    }
};
```
```cpp
#include <iostream>

using namespace std;

class Complex{
private:
    double real, imag;

public:
    Complex();
    Complex (double r);
    Complex (double r, double i);

    void getValue();
    Complex (Complex c1, Complex c2);
    ~Complex (){};
};

Complex::Complex(){
    real = 0;
    imag = 0;
}

Complex::Complex(double r, double i){
    real = r;
    imag = i;
}

Complex::Complex(double r){
    real = r;
}

Complex::Complex(Complex c1, Complex c2){
    real = c1.real + c2.real;
    imag = c1.imag + c2.imag;
}

void Complex::getValue(){
    cout<<real<<endl;
}

int main(int argc, char *argv[]){
    Complex c0;     // 用到的是第一个构造函数，因为没有参数，使用下面的定义对象也一样，但是无参数的时候，一般使用这样定义的对象
    //Complex c0();
    Complex c1(2, 3);
    Complex c2(4);
    Complex c3(c1, c2);     // 这个要注意
    Complex *pc = new Complex(4, 5);    // 这个重要，要将参数加上
    pc->getValue();     // 指向类的指针，使用的是 "->" 符号访问成员
    c3.getValue();      // 对象使用的 "." 访问成员
    
    return 0;
}
```

### 赋值构造函数
同样，如果没有自己定义，则**编译器** 会自动生成一个复制构造函数；  
复制构造函数不允许多个，因为复制构造函数是做复制操作，没法用参数个数和类型来区分用了哪一个复制构造函数，所以只有一个；  
没有返回值，参数是类的引用或者常引用。  
```cpp
X(X&);  //X是类名
X(const X&);    // 常引用，说明复制构造函数不允许改变被复制对象，这是合理的，因为复制操作，不需要改变被复制对象
```
参数是引用的原因：**如果不是引用，在传递参数的时候就会被调用复制构造函数，而这个函数本身就是复制构造函数，会造成无穷的递归调用**  
	
1. 使用方式
    - 当不自定义复制构造函数，那么编译器会自动生成一个复制构造函数，该函数将实现**浅拷贝**，也就是只是实现了赋值操作；  
    - 浅拷贝和深拷贝的区别，前者只是实现简单的赋值操作，当类中存在指针成员变量，因为只是赋值，那么两个指针将指向同一块地址，每一个对象在结束后都会调用西沟函数，那么使用浅拷贝的两个对象的析构，将对指针指向的同一块内存析构两次。深拷贝就是对于指针成员变量，另开辟内存空间，其他的成员变量进行赋值就够了。要想实现深拷贝，只能自己实现。具体可参见[浅拷贝和深拷贝的区别](https://blog.csdn.net/u010700335/article/details/39830425)。

2. 复制构造函数起作用的2种情况
    - 用对象去初始化另一个对象(赋值不是，赋值调用的默认的赋值运算符"="，或者是该运算符的重载)
    - 对象作为函数的参数，(由于会调用赋值构造函数造成消耗，所以一般使用对象的引用作为参数)
    - 补充：返回值是对象(不是对象的引用), 以前是要调用复制构造函数，现在编译器对函数进行了优化，不需要再调用复制构造函数，直接返回值了。(**如何直接返回？是调用了赋值运算符么？尚不清楚**)

### 函数返回值： 引用 和 指针
对于在函数内部定义的临时变量和指针，是不能作为函数返回值的，这是因为在return该量的时候，发生了复制工作(不一定是赋值，赋值运算符=在C++会被重载,这个时候，赋值就不一定是复制了)。  
当是指针的时候，接收的指针=return的指针，但是当return结束后，临时变量都会被销毁，那么接收的指针指向的地址也被消亡了，变成了野指针；  
当返回值类型是引用的时候，返回的就是return 变量的引用，其实返回值直接就是该变量本身，因为引用只是变量的别名。当return 的是临时变量的时候，因为会被销毁，所以编译会出错；  
返回值是引用，也就是被引用变量本身，所以该函数就是左值，可以放在等号的左边，进行其他操作；  
要注意的是，当参数是是引用的时候，直接return 引用就可以了。
```cpp
#include <iostream>
using namespace std;

int gl = 2;
int & foo(){
    gl = 1;
    return gl; // 返回的是gl 的引用
}

int & fun(int &a){
    a += 1;
    return a; //返回的是a的引用
}

int main(int argc, char*argv[]){
    foo() = 4;
    cout<<gl<<endl; // 4
    int a = 2;
    fun(a);
    cout<<a<<endl;  //3
    int b = foo();
    cout<<b<<endl;  //1
    cout<<gl<<endl; //1

    return 0;
}
```

### 左值和右值



### const 关键字
要讲const作用，要先从需求说起，就是希望在使用过程中不变，如果改变则编译不通过，这样可以保证写出的程序更鲁棒：　

|对象 |目的 |
|:-:|:-:|
|变量 | 希望某个变量不会改变|
|函数参数 | 希望在函数内部变量不会改变|
| 函数返回值| 希望返回对象在后面的使用中不会改变|
| 类的成员函数| 该成员函数内部不能修改对象的成员|

```cpp

```
